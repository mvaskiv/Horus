'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function add(first, second) {
	return first + second;
}

var _ref = {},
    hasOwnProperty = _ref.hasOwnProperty;

function hasOwn(prop, obj) {
	return hasOwnProperty.call(obj, prop);
}

function assign() {
	// eslint-disable-next-line no-func-assign
	assign = Object.assign || function (target) {
		for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			sources[_key - 1] = arguments[_key];
		}

		sources.forEach(function (source) {
			for (var key in source) {
				if (hasOwn(key, source)) {
					target[key] = source[key];
				}
			}
		});
		return target;
	};
	return assign.apply(undefined, arguments);
}

var isArray = Array.isArray;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

function isObject(obj) {
	return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null && !isArray(obj);
}

function mapValues(iteratee, obj) {
	return Object.keys(obj).reduce(function (acc, key) {
		acc[key] = iteratee(obj[key]);
		return acc;
	}, {});
}

function cloneDeep(value) {
	if (isArray(value)) {
		return value.map(cloneDeep);
	}

	if (isObject(value)) {
		return mapValues(cloneDeep, value);
	}

	return value;
}

function camelCase(text) {
	return text.replace(/^[_.\- ]+/, '').toLowerCase().replace(/[_.\- ]+(\w|$)/g, function (__, p1) {
		return p1.toUpperCase();
	});
}

function compact(collection) {
	return isArray(collection) ? collection.filter(Boolean) : Object.keys(collection).reduce(function (result, key) {
		if (collection[key]) {
			result[key] = collection[key];
		}
		return result;
	}, {});
}

function compose() {
	for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
		funcs[_key] = arguments[_key];
	}

	return funcs.reduce(function (composed, next) {
		return function () {
			return composed(next.apply(undefined, arguments));
		};
	});
}

function dropRight(count, arr) {
	return arr.slice(0, -count);
}

// eslint-disable-next-line consistent-return
function find(predicate, arr) {
	for (var index = 0; index < arr.length; index++) {
		var element = arr[index];
		if (predicate(element)) {
			return element;
		}
	}
}

function findIndex(predicate, arr) {
	for (var index = 0; index < arr.length; index++) {
		if (predicate(arr[index])) {
			return index;
		}
	}

	return -1;
}

// eslint-disable-next-line consistent-return
function findLast(predicate, arr) {
	for (var index = arr.length - 1; index >= 0; index--) {
		if (predicate(arr[index])) {
			return arr[index];
		}
	}
}

function findLastIndexFrom(predicate, startIndex, arr) {
	for (var index = startIndex; index >= 0; index--) {
		if (predicate(arr[index])) {
			return index;
		}
	}

	return -1;
}

function findLastIndex(predicate, arr) {
	return findLastIndexFrom(predicate, arr.length - 1, arr);
}

function flatMap(iteratee, arr) {
	var _ref;

	return (_ref = []).concat.apply(_ref, arr.map(iteratee));
}

// eslint-disable-next-line lodash-fp/prefer-identity
function identity(value) {
	return value;
}

function flatten(arr) {
	return flatMap(identity, arr);
}

function forOwn(callback, obj) {
	return Object.keys(obj).forEach(function (key) {
		callback(obj[key], key);
	});
}

function fromPairs(pairs) {
	return pairs.reduce(function (obj, _ref) {
		var key = _ref[0],
		    value = _ref[1];

		obj[key] = value;
		return obj;
	}, {});
}

function generateRandomId() {
	return Math.random().toString(36).substring(2);
}

function generateUniqueId(map) {
	var id = generateRandomId();
	return hasOwn(id, map) ? generateUniqueId(map) : id;
}

// based on https://github.com/developit/dlv/blob/d7ec976d12665f1c25dec2acf955dfc2e8757a9c/index.js
function get$1(propPath, obj) {
	var arrPath = typeof propPath === 'string' ? propPath.split('.') : propPath;
	var pathPartIndex = 0;
	var result = obj;
	while (result && pathPartIndex < arrPath.length) {
		result = result[arrPath[pathPartIndex++]];
	}
	return result;
}

function getOr(defaultValue, prop, obj) {
	var propValue = get$1(prop, obj);
	return propValue !== undefined && propValue !== null ? propValue : defaultValue;
}

function groupBy(mapper, collection) {
	return Object.keys(collection).reduce(function (grouped, key) {
		var element = collection[key];
		var groupKey = mapper(element);
		grouped[groupKey] = grouped[groupKey] || [];
		grouped[groupKey].push(element);
		return grouped;
	}, {});
}

function groupKeys(mapper, obj) {
	return Object.keys(obj).reduce(function (grouped, key) {
		var groupKey = mapper(key);
		grouped[groupKey] = grouped[groupKey] || {};
		grouped[groupKey][key] = obj[key];
		return grouped;
	}, {});
}

function includes(value, arr) {
	return arr.indexOf(value) !== -1;
}

function isEmpty(collection) {
	return (isArray(collection) ? collection : Object.keys(collection)).length === 0;
}

function keyBy(prop, arr) {
	return arr.reduce(function (acc, el) {
		acc[el[prop]] = el;
		return acc;
	}, {});
}

function last(arr) {
	return arr.length > 0 ? arr[arr.length - 1] : null;
}

function mapKeys(mapper, obj) {
	return Object.keys(obj).reduce(function (acc, key) {
		acc[mapper(key)] = obj[key];
		return acc;
	}, {});
}

function mapValuesIndexed(iteratee, obj) {
	return Object.keys(obj).reduce(function (acc, key) {
		acc[key] = iteratee(obj[key], key);
		return acc;
	}, {});
}

function merge(objA, objB) {
	if (isEmpty(objB)) {
		return objA;
	}

	var result = {};

	forOwn(function (value, key) {
		if (hasOwn(key, objB)) {
			if (isObject(objA[key]) && isObject(objB[key])) {
				result[key] = merge(objA[key], objB[key]);
			} else {
				result[key] = objB[key];
			}
		} else {
			result[key] = objA[key];
		}
	}, objA);

	forOwn(function (value, key) {
		if (!hasOwn(key, result)) {
			result[key] = objB[key];
		}
	}, objB);

	return result;
}

function mergeAll(objs) {
	if (objs.length === 0) {
		return {};
	}

	var first = objs[0],
	    rest = objs.slice(1);

	return rest.reduce(function (merged, obj) {
		return merge(merged, obj);
	}, first);
}

function memoize(func) {
	var keys = [];
	var values = [];
	return function () {
		var key = arguments.length <= 0 ? undefined : arguments[0];
		var index = keys.indexOf(key);

		if (index !== -1) {
			return values[index];
		}

		var value = func.apply(undefined, arguments);
		keys.push(key);
		values.push(value);
		return value;
	};
}

function memoizeOne(fn) {
	var called = false;
	var memoized = void 0;
	var cacheKey = void 0;

	return function () {
		if (called && (arguments.length <= 0 ? undefined : arguments[0]) === cacheKey) {
			return memoized;
		}
		called = true;
		cacheKey = arguments.length <= 0 ? undefined : arguments[0];
		memoized = fn.apply(undefined, arguments);
		return memoized;
	};
}

function noop() {}

function values(obj) {
	return Object.keys(obj).map(function (key) {
		return obj[key];
	});
}

function numericSortBy(propOrMapper, collection) {
	var mapper = typeof propOrMapper === 'function' ? propOrMapper : function (element) {
		return get$1(propOrMapper, element);
	};
	return (isArray(collection) ? [].concat(collection) : values(collection)).sort(function (elementA, elementB) {
		return mapper(elementA) - mapper(elementB);
	});
}

function omitByIndexed(predicate, obj) {
	return Object.keys(obj).reduce(function (acc, key) {
		if (!predicate(obj[key], key)) {
			acc[key] = obj[key];
		}
		return acc;
	}, {});
}

function omit(keys, obj) {
	return omitByIndexed(function (value, key) {
		return keys.indexOf(key) !== -1;
	}, obj);
}

function omitBy(predicate, obj) {
	return Object.keys(obj).reduce(function (acc, key) {
		if (!predicate(obj[key])) {
			acc[key] = obj[key];
		}
		return acc;
	}, {});
}

function once(fn) {
	var called = false;
	var result = void 0;
	return function () {
		if (called) {
			return result;
		}
		called = true;
		return result = fn.apply(undefined, arguments);
	};
}

function pick(props, obj) {
	return props.reduce(function (acc, prop) {
		acc[prop] = obj[prop];
		return acc;
	}, {});
}

function pickBy(predicate, obj) {
	return Object.keys(obj).reduce(function (acc, key) {
		if (predicate(obj[key])) {
			acc[key] = obj[key];
		}
		return acc;
	}, {});
}

function pickByIndexed(predicate, obj) {
	return Object.keys(obj).reduce(function (acc, key) {
		if (predicate(obj[key], key)) {
			acc[key] = obj[key];
		}
		return acc;
	}, {});
}

function pickOwn(props, obj) {
	return props.reduce(function (acc, prop) {
		if (hasOwn(prop, obj)) {
			acc[prop] = obj[prop];
		}
		return acc;
	}, {});
}

function reject(predicate, arr) {
	return arr.filter(function (element) {
		return !predicate(element);
	});
}

function removeAt(index, arr) {
	var copy = [].concat(arr);
	copy.splice(index, 1);
	return copy;
}

// https://github.com/reactjs/react-redux/blob/5d792a283554cff3d2f54fad1be1f79cbcab33fe/src/utils/shallowEqual.js

function is(first, second) {
	if (first === second) {
		return first !== 0 || second !== 0 || 1 / first === 1 / second;
	}
	// eslint-disable-next-line no-self-compare
	return first !== first && second !== second;
}

function shallowEqual(objA, objB) {
	if (is(objA, objB)) return true;

	if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
		return false;
	}

	var keysA = Object.keys(objA);
	var keysB = Object.keys(objB);

	if (keysA.length !== keysB.length) return false;

	for (var index = 0; index < keysA.length; index++) {
		if (!hasOwn(keysA[index], objB) || !is(objA[keysA[index]], objB[keysA[index]])) {
			return false;
		}
	}

	return true;
}

function splitAt(splitPoint, arr) {
	// TODO first item from the tuple could be replaced by dropRight
	return [arr.slice(0, splitPoint), arr.slice(splitPoint, arr.length)];
}

function splitRightWhenAccum(fn, acc, arr) {
	var result = false;

	for (var index = arr.length; index > 0; index--) {
		var _fn = fn(arr[index - 1], acc);
		// eslint-disable-next-line no-param-reassign


		result = _fn[0];
		acc = _fn[1];


		if (result) {
			return splitAt(index - 1, arr);
		}
	}

	return [[], arr];
}

function sum(numbers) {
	return numbers.reduce(add, 0);
}

function takeRightWhileFrom(predicate, startIndex, arr) {
	var endIndex = findLastIndexFrom(function (element) {
		return !predicate(element);
	}, startIndex, arr);
	return endIndex === startIndex ? [] : arr.slice(endIndex + 1, startIndex + 1);
}

function throttle(ms, fn) {
	var lastCall = Date.now() - 2 * ms;
	var result = void 0;
	var trailing = void 0;

	var invoke = function invoke() {
		lastCall = Date.now();
		return result = fn.apply(undefined, arguments);
	};

	return function () {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		var now = Date.now();

		if (now - lastCall >= ms) {
			return invoke.apply(undefined, args);
		}

		clearTimeout(trailing);
		trailing = setTimeout.apply(undefined, [invoke, lastCall - now + ms].concat(args));

		return result;
	};
}

function toPairs(obj) {
	return Object.keys(obj).map(function (key) {
		return [key, obj[key]];
	});
}

var leadingWhiteSpace = /^\s+/;

function trimStart(str) {
	return str.replace(leadingWhiteSpace, '');
}

var trailingWhiteSpace = /\s+$/;

function trimEnd(str) {
	return str.replace(trailingWhiteSpace, '');
}

function uniq(arr) {
	// with polyfills this could be just: return Array.from(new Set(arr))
	var seen = [];
	return arr.filter(function (element) {
		if (seen.indexOf(element) === -1) {
			seen.push(element);
			return true;
		}
		return false;
	});
}

function update(index, newElement, arr) {
	return [].concat(arr.slice(0, index), [newElement], arr.slice(index + 1, arr.length));
}

function without(removed, arr) {
	return arr.filter(function (element) {
		return removed.indexOf(element) === -1;
	});
}

exports.add = add;
exports.assign = assign;
exports.cloneDeep = cloneDeep;
exports.camelCase = camelCase;
exports.compact = compact;
exports.compose = compose;
exports.dropRight = dropRight;
exports.find = find;
exports.findIndex = findIndex;
exports.findLast = findLast;
exports.findLastIndex = findLastIndex;
exports.findLastIndexFrom = findLastIndexFrom;
exports.flatMap = flatMap;
exports.flatten = flatten;
exports.forOwn = forOwn;
exports.fromPairs = fromPairs;
exports.generateRandomId = generateRandomId;
exports.generateUniqueId = generateUniqueId;
exports.get = get$1;
exports.getOr = getOr;
exports.groupBy = groupBy;
exports.groupKeys = groupKeys;
exports.hasOwn = hasOwn;
exports.identity = identity;
exports.includes = includes;
exports.isArray = isArray;
exports.isEmpty = isEmpty;
exports.isObject = isObject;
exports.keyBy = keyBy;
exports.last = last;
exports.mapKeys = mapKeys;
exports.mapValues = mapValues;
exports.mapValuesIndexed = mapValuesIndexed;
exports.merge = merge;
exports.mergeAll = mergeAll;
exports.memoize = memoize;
exports.memoizeOne = memoizeOne;
exports.noop = noop;
exports.numericSortBy = numericSortBy;
exports.omit = omit;
exports.omitBy = omitBy;
exports.omitByIndexed = omitByIndexed;
exports.once = once;
exports.pick = pick;
exports.pickBy = pickBy;
exports.pickByIndexed = pickByIndexed;
exports.pickOwn = pickOwn;
exports.reject = reject;
exports.removeAt = removeAt;
exports.shallowEqual = shallowEqual;
exports.splitAt = splitAt;
exports.splitRightWhenAccum = splitRightWhenAccum;
exports.sum = sum;
exports.takeRightWhileFrom = takeRightWhileFrom;
exports.throttle = throttle;
exports.toPairs = toPairs;
exports.trimStart = trimStart;
exports.trimEnd = trimEnd;
exports.uniq = uniq;
exports.update = update;
exports.values = values;
exports.without = without;
